<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NFT Marketplace - Solana Tamagotchi</title>
    <meta property="og:title" content="NFT Marketplace - Solana Tamagotchi">
    <meta property="og:description" content="Buy and sell NFT pets on the marketplace!">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
    <script src="https://unpkg.com/@solana/wallet-adapter-base@latest/lib/index.iife.min.js"></script>
    <script src="https://unpkg.com/@solana/wallet-adapter-wallets@latest/lib/index.iife.min.js"></script>
    <script src="https://unpkg.com/@solana/wallet-adapter-phantom@latest/lib/index.iife.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 50%, #0f1419 100%);
            min-height: 100vh;
            padding: 20px;
            font-family: 'Arial', sans-serif;
            color: white;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px;
            background: rgba(255,255,255,0.05);
            border-radius: 20px;
            border: 2px solid rgba(138, 201, 38, 0.3);
            position: relative;
        }
        
        .auth-section {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .auth-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            font-size: 14px;
        }
        
        .auth-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .wallet-connected {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .wallet-address {
            font-family: monospace;
            font-size: 11px;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .user-balance {
            background: rgba(138, 201, 38, 0.2);
            border: 1px solid rgba(138, 201, 38, 0.4);
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: bold;
        }
        
        .balance-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .not-authenticated {
            text-align: center;
            padding: 60px 20px;
            background: rgba(0,0,0,0.3);
            border-radius: 20px;
            margin: 40px 0;
        }
        
        .not-authenticated h2 {
            color: #8AC926;
            margin-bottom: 20px;
            font-size: 28px;
        }
        
        .not-authenticated p {
            color: rgba(255,255,255,0.7);
            margin-bottom: 30px;
            font-size: 16px;
        }
        
        .auth-options {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .auth-option {
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(138, 201, 38, 0.3);
            border-radius: 15px;
            padding: 20px;
            min-width: 200px;
            text-align: center;
        }
        
        .auth-option h3 {
            color: #8AC926;
            margin-bottom: 15px;
            font-size: 18px;
        }
        
        .auth-option p {
            color: rgba(255,255,255,0.6);
            font-size: 14px;
            margin-bottom: 15px;
        }
        
        h1 {
            color: #8AC926;
            margin-bottom: 10px;
            font-size: 42px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .subtitle {
            color: rgba(255,255,255,0.7);
            font-size: 18px;
        }
        
        /* Tabs */
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .tab-btn {
            padding: 15px 30px;
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(138, 201, 38, 0.3);
            border-radius: 12px;
            color: white;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .tab-btn.active {
            background: linear-gradient(135deg, #8AC926 0%, #6aa519 100%);
            border-color: #8AC926;
            box-shadow: 0 4px 15px rgba(138, 201, 38, 0.4);
        }
        
        .tab-btn:hover {
            background: rgba(138, 201, 38, 0.2);
        }
        
        /* Filters */
        .filters {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .filter-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .filter-select {
            padding: 12px 20px;
            background: rgba(0,0,0,0.3);
            border: 2px solid rgba(138, 201, 38, 0.3);
            border-radius: 10px;
            color: white;
            font-size: 14px;
            cursor: pointer;
        }
        
        .filter-select option {
            background: #1a1f3a;
            color: white;
        }
        
        /* NFT Grid */
        .nft-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 25px;
            margin-bottom: 40px;
        }
        
        .nft-card {
            background: linear-gradient(135deg, rgba(255,255,255,0.08) 0%, rgba(255,255,255,0.03) 100%);
            border-radius: 20px;
            padding: 20px;
            border: 2px solid rgba(138, 201, 38, 0.2);
            transition: all 0.3s;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        
        .nft-card:hover {
            transform: translateY(-5px);
            border-color: #8AC926;
            box-shadow: 0 10px 30px rgba(138, 201, 38, 0.3);
        }
        
        .nft-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #8AC926, #10b981, #8AC926);
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .nft-card:hover::before {
            opacity: 1;
        }
        
        .nft-image {
            width: 100%;
            aspect-ratio: 1;
            background: linear-gradient(135deg, rgba(138, 201, 38, 0.2), rgba(16, 185, 129, 0.2));
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 80px;
            margin-bottom: 15px;
            border: 2px solid rgba(138, 201, 38, 0.3);
        }
        
        .nft-badge {
            position: absolute;
            top: 15px;
            right: 15px;
            padding: 5px 12px;
            background: rgba(239, 68, 68, 0.9);
            border-radius: 20px;
            font-size: 11px;
            font-weight: bold;
            color: white;
        }
        
        .nft-info {
            margin-bottom: 15px;
        }
        
        .nft-name {
            font-size: 18px;
            font-weight: bold;
            color: #8AC926;
            margin-bottom: 8px;
        }
        
        .nft-attributes {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }
        
        .attribute-badge {
            padding: 5px 10px;
            background: rgba(138, 201, 38, 0.2);
            border-radius: 8px;
            font-size: 12px;
            border: 1px solid rgba(138, 201, 38, 0.3);
        }
        
        .nft-price {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 15px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        
        .price-label {
            font-size: 12px;
            color: rgba(255,255,255,0.6);
        }
        
        .price-value {
            font-size: 24px;
            font-weight: bold;
            color: #10b981;
        }
        
        .price-tama {
            font-size: 14px;
            color: rgba(255,255,255,0.7);
        }
        
        .nft-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .btn-buy {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
        }
        
        .btn-buy:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
        }
        
        .btn-sell {
            background: linear-gradient(135deg, #8AC926, #6aa519);
            color: white;
        }
        
        .btn-sell:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(138, 201, 38, 0.4);
        }
        
        .btn-cancel {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            border: 2px solid #ef4444;
        }
        
        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 10000;
            align-items: center;
            justify-content: center;
        }
        
        .modal.active {
            display: flex;
        }
        
        .modal-content {
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
            border-radius: 20px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            border: 2px solid rgba(138, 201, 38, 0.3);
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .modal-title {
            font-size: 24px;
            color: #8AC926;
        }
        
        .close-btn {
            background: rgba(239, 68, 68, 0.2);
            border: 2px solid #ef4444;
            color: #ef4444;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-label {
            display: block;
            margin-bottom: 8px;
            color: rgba(255,255,255,0.8);
            font-size: 14px;
        }
        
        .form-input {
            width: 100%;
            padding: 12px;
            background: rgba(0,0,0,0.3);
            border: 2px solid rgba(138, 201, 38, 0.3);
            border-radius: 10px;
            color: white;
            font-size: 16px;
        }
        
        .form-input:focus {
            outline: none;
            border-color: #8AC926;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: rgba(255,255,255,0.05);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid rgba(138, 201, 38, 0.2);
            text-align: center;
        }
        
        .stat-value {
            font-size: 32px;
            font-weight: bold;
            color: #8AC926;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 14px;
            color: rgba(255,255,255,0.6);
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: rgba(255,255,255,0.6);
        }
        
        .spinner {
            border: 4px solid rgba(138, 201, 38, 0.3);
            border-top: 4px solid #8AC926;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: rgba(255,255,255,0.6);
        }
        
        .empty-state-icon {
            font-size: 80px;
            margin-bottom: 20px;
            opacity: 0.5;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="auth-section" id="auth-section">
                <div id="auth-status">Loading...</div>
            </div>
            <h1>üõí NFT Marketplace</h1>
            <p class="subtitle">Buy and sell your NFT pets</p>
        </div>
        
        <!-- Not Authenticated Screen -->
        <div id="not-authenticated" class="not-authenticated" style="display: none;">
            <h2>üîê Connect to Marketplace</h2>
            <p>Please connect your wallet or login via Telegram to access the marketplace</p>
            <div class="auth-options">
                <div class="auth-option">
                    <h3>üëõ Connect Wallet</h3>
                    <p>Connect your Phantom wallet to buy and sell NFTs</p>
                    <button class="auth-btn" onclick="connectPhantomWallet()">Connect Phantom</button>
                </div>
                <div class="auth-option">
                    <h3>üì± Telegram Login</h3>
                    <p>Login via Telegram to access your NFTs</p>
                    <button class="auth-btn" onclick="loginViaTelegram()">Login via Telegram</button>
                </div>
            </div>
        </div>
        
        <!-- Authenticated Content -->
        <div id="authenticated-content">
        
        <!-- Stats -->
        <div class="stats">
            <div class="stat-card">
                <div class="stat-value" id="total-listed">0</div>
                <div class="stat-label">NFTs Listed</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="total-sales">0</div>
                <div class="stat-label">Total Sales</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="floor-price">-</div>
                <div class="stat-label">Floor Price (TAMA)</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="volume">0</div>
                <div class="stat-label">Volume (TAMA)</div>
            </div>
        </div>
        
        <!-- Tabs -->
        <div class="tabs">
            <button class="tab-btn active" data-tab="browse">üõí Browse</button>
            <button class="tab-btn" data-tab="my-listings">üìã My Listings</button>
            <button class="tab-btn" data-tab="my-sales">üí∞ My Sales</button>
        </div>
        
        <!-- Filters -->
        <div class="filters">
            <div class="filter-group">
                <label for="filter-tier" style="color: rgba(255,255,255,0.8);">Tier:</label>
                <select class="filter-select" id="filter-tier">
                    <option value="">All Tiers</option>
                    <option value="Bronze">ü•â Bronze</option>
                    <option value="Silver">ü•à Silver</option>
                    <option value="Gold">ü•á Gold</option>
                </select>
            </div>
            <div class="filter-group">
                <label for="filter-rarity" style="color: rgba(255,255,255,0.8);">Rarity:</label>
                <select class="filter-select" id="filter-rarity">
                    <option value="">All Rarities</option>
                    <option value="Common">‚ö™ Common</option>
                    <option value="Uncommon">üü¢ Uncommon</option>
                    <option value="Rare">üîµ Rare</option>
                    <option value="Epic">üü£ Epic</option>
                    <option value="Legendary">üü† Legendary</option>
                </select>
            </div>
            <div class="filter-group">
                <label for="filter-sort" style="color: rgba(255,255,255,0.8);">Sort:</label>
                <select class="filter-select" id="filter-sort">
                    <option value="price-asc">Price: Low to High</option>
                    <option value="price-desc">Price: High to Low</option>
                    <option value="rarity-desc">Rarity: High to Low</option>
                    <option value="newest">Newest First</option>
                </select>
            </div>
            <button class="btn btn-sell" onclick="openSellModal()">‚ûï List NFT for Sale</button>
        </div>
        
        <!-- NFT Grid -->
        <div class="nft-grid" id="nft-grid">
            <div class="loading">
                <div class="spinner"></div>
                <p>Loading marketplace...</p>
            </div>
        </div>
        </div>
        <!-- End Authenticated Content -->
    
    <!-- Sell Modal -->
    <div class="modal" id="sell-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">üìã List NFT for Sale</h2>
                <button class="close-btn" onclick="closeSellModal()">‚úï</button>
            </div>
            <div id="sell-form">
                <div class="form-group">
                    <label for="sell-nft-select" class="form-label">Select NFT:</label>
                    <select class="form-input" id="sell-nft-select">
                        <option value="">Loading your NFTs...</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="sell-payment-type" class="form-label">Payment Type:</label>
                    <select class="form-input" id="sell-payment-type" onchange="updateSellForm()">
                        <option value="tama">üí∞ TAMA</option>
                        <option value="sol">üíé SOL</option>
                        <option value="both">üí∞ TAMA or üíé SOL</option>
                    </select>
                </div>
                <div class="form-group" id="sell-price-tama-group">
                    <label for="sell-price-tama" class="form-label">Price (TAMA):</label>
                    <input type="number" class="form-input" id="sell-price-tama" placeholder="e.g. 10000" min="1000">
                    <small style="color: rgba(255,255,255,0.5);">Minimum: 1,000 TAMA</small>
                </div>
                <div class="form-group" id="sell-price-sol-group" style="display: none;">
                    <label for="sell-price-sol" class="form-label">Price (SOL):</label>
                    <input type="number" class="form-input" id="sell-price-sol" placeholder="e.g. 0.1" step="0.001" min="0.001">
                    <small style="color: rgba(255,255,255,0.5);">Minimum: 0.001 SOL</small>
                </div>
                <div class="form-group">
                    <div class="form-label" style="margin-bottom: 8px;">Platform Fee: 5%</div>
                    <div style="color: rgba(255,255,255,0.7); font-size: 14px;">
                        You will receive: <span id="sell-receive">0</span> <span id="sell-receive-currency">TAMA</span>
                    </div>
                </div>
                <button class="btn btn-sell" onclick="listNFT()" style="width: 100%; margin-top: 20px;">
                    ‚úÖ List for Sale
                </button>
            </div>
        </div>
    </div>
    
    <!-- Buy Modal -->
    <div class="modal" id="buy-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">üõí Buy NFT</h2>
                <button class="close-btn" onclick="closeBuyModal()">‚úï</button>
            </div>
            <div id="buy-details"></div>
            <div style="margin-top: 20px;">
                <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; margin-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                        <span style="color: rgba(255,255,255,0.7);">Price:</span>
                        <span id="buy-price" style="color: #10b981; font-weight: bold; font-size: 20px;">0 TAMA</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                        <span style="color: rgba(255,255,255,0.7);">Platform Fee (5%):</span>
                        <span id="buy-fee" style="color: #ef4444;">0 TAMA</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1);">
                        <span style="color: rgba(255,255,255,0.7); font-weight: bold;">Total:</span>
                        <span id="buy-total" style="color: #8AC926; font-weight: bold; font-size: 18px;">0 TAMA</span>
                    </div>
                </div>
                <div style="margin-bottom: 15px;">
                    <div style="color: rgba(255,255,255,0.7); font-size: 14px; margin-bottom: 5px;">Your Balance:</div>
                    <div id="buy-balance" style="color: #8AC926; font-weight: bold; font-size: 18px;">Loading...</div>
                </div>
                <button class="btn btn-buy" onclick="buyNFT()" style="width: 100%;" id="buy-btn">
                    üí∞ Buy Now
                </button>
            </div>
        </div>
    </div>
    
    <script>
        // Supabase Configuration
        const SUPABASE_URL = 'https://zfrazyupameidxpjihrh.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InpmcmF6eXVwYW1laWR4cGppaHJoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTk5Mzc1NTAsImV4cCI6MjA3NTUxMzU1MH0.1EkMDqCNJoAjcJDh3Dd3yPfus-JpdcwE--z2dhjh7wU';
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        
        const API_BASE = 'https://api.solanatamagotchi.com/api/tama';
        
        let currentTab = 'browse';
        let currentFilters = {};
        let selectedNFT = null;
        let userTelegramId = null;
        let walletAddress = null;
        let isAuthenticated = false;
        let phantomWallet = null;
        
        // Solana Connection
        const SOLANA_NETWORK = 'devnet';
        let connection = null;
        if (typeof solanaWeb3 !== 'undefined') {
            connection = new solanaWeb3.Connection(
                SOLANA_NETWORK === 'mainnet' 
                    ? 'https://api.mainnet-beta.solana.com'
                    : 'https://api.devnet.solana.com',
                'confirmed'
            );
        }
        
        // Initialize Authentication
        async function initAuth() {
            // Check localStorage for saved auth session
            const savedSession = localStorage.getItem('gotchi_auth_session');
            if (savedSession) {
                try {
                    const session = JSON.parse(savedSession);
                    if (session.telegramId) {
                        userTelegramId = session.telegramId.toString();
                        isAuthenticated = true;
                        console.log('Restored session from localStorage:', userTelegramId);
                    }
                } catch (e) {
                    console.warn('Failed to parse saved session:', e);
                }
            }
            
            // Check URL parameters for telegram_id
            const urlParams = new URLSearchParams(window.location.search);
            const urlTelegramId = urlParams.get('user_id') || urlParams.get('tg_id');
            if (urlTelegramId) {
                userTelegramId = urlTelegramId.toString();
                isAuthenticated = true;
                console.log('Found telegram_id in URL:', userTelegramId);
            }
            
            // Wait for auth system to be ready
            if (window.GotchiAuth) {
                await window.GotchiAuth.initAuth();
                // Update from GotchiAuth if available
                if (window.GotchiAuth.isAuthenticated) {
                    userTelegramId = window.GotchiAuth.telegramId || userTelegramId;
                    isAuthenticated = true;
                }
                updateAuthStatus();
            } else {
                // Wait for auth to load
                const checkAuth = setInterval(() => {
                    if (window.GotchiAuth) {
                        clearInterval(checkAuth);
                        window.GotchiAuth.initAuth().then(() => {
                            if (window.GotchiAuth.isAuthenticated) {
                                userTelegramId = window.GotchiAuth.telegramId || userTelegramId;
                                isAuthenticated = true;
                            }
                            updateAuthStatus();
                        });
                    }
                }, 100);
                
                // Timeout after 5 seconds
                setTimeout(() => {
                    clearInterval(checkAuth);
                    updateAuthStatus();
                }, 5000);
            }
            
            // Check for Phantom wallet
            if (window.solana && window.solana.isPhantom) {
                phantomWallet = window.solana;
                if (phantomWallet.isConnected) {
                    walletAddress = phantomWallet.publicKey.toString();
                    isAuthenticated = true;
                    updateAuthStatus();
                }
            }
            
            // Update auth status immediately
            updateAuthStatus();
        }
        
        // Load and display user balance
        async function loadAndDisplayBalance() {
            try {
                let tamaBalance = 0;
                let solBalance = 0;
                
                // Load TAMA balance from API (only if Telegram is connected)
                if (userTelegramId) {
                    const response = await fetch(`${API_BASE}/balance?telegram_id=${userTelegramId}`);
                    if (response.ok) {
                        const data = await response.json();
                        tamaBalance = data.balance || 0;
                    }
                    
                    // Update TAMA display
                    const tamaBalanceEl = document.getElementById('tama-balance');
                    if (tamaBalanceEl) {
                        tamaBalanceEl.textContent = formatNumber(tamaBalance);
                    }
                }
                
                // Load SOL balance from wallet (only if wallet is connected)
                if (walletAddress && connection) {
                    try {
                        const solBalanceLamports = await connection.getBalance(new solanaWeb3.PublicKey(walletAddress));
                        solBalance = (solBalanceLamports / solanaWeb3.LAMPORTS_PER_SOL).toFixed(4);
                    } catch (e) {
                        console.error('Failed to load SOL balance:', e);
                        solBalance = '0';
                    }
                    
                    // Update SOL display
                    const solBalanceEl = document.getElementById('sol-balance');
                    if (solBalanceEl) {
                        solBalanceEl.textContent = solBalance;
                    }
                }
            } catch (error) {
                console.error('Failed to load balance:', error);
                // Only update elements that exist
                const tamaBalanceEl = document.getElementById('tama-balance');
                const solBalanceEl = document.getElementById('sol-balance');
                if (tamaBalanceEl) tamaBalanceEl.textContent = '0';
                if (solBalanceEl) solBalanceEl.textContent = '0';
            }
        }
        
        // Update authentication status UI
        function updateAuthStatus() {
            const authSection = document.getElementById('auth-section');
            const notAuthScreen = document.getElementById('not-authenticated');
            const authContent = document.getElementById('authenticated-content');
            
            if (!authSection || !notAuthScreen || !authContent) {
                return; // Elements not loaded yet
            }
            
            // Check Telegram auth
            if (window.GotchiAuth && window.GotchiAuth.isAuthenticated) {
                userTelegramId = window.GotchiAuth.telegramId;
                isAuthenticated = true;
            } else if (window.GotchiAuth) {
                userTelegramId = window.GotchiAuth.getTelegramUserId() || null;
            }
            
            // Check wallet connection
            if (phantomWallet && phantomWallet.isConnected) {
                walletAddress = phantomWallet.publicKey.toString();
                isAuthenticated = true;
            }
            
            // Always show content if we have any auth method
            if (isAuthenticated || userTelegramId || walletAddress) {
                isAuthenticated = true;
                notAuthScreen.style.display = 'none';
                if (authContent) {
                    authContent.style.display = 'block';
                }
                
                // Update auth section
                let authHtml = '';
                
                // Add balance display (conditionally show TAMA/SOL based on auth method)
                const showTama = !!userTelegramId;
                const showSol = !!walletAddress;
                
                if (showTama || showSol) {
                    authHtml += `<div class="user-balance" id="user-balance-display">`;
                    
                    if (showTama) {
                        authHtml += `<div class="balance-item">üí∞ <span id="tama-balance">Loading...</span> TAMA</div>`;
                    }
                    
                    if (showSol) {
                        authHtml += `<div class="balance-item">üíé <span id="sol-balance">Loading...</span> SOL</div>`;
                    }
                    
                    authHtml += `</div>`;
                }
                
                if (userTelegramId) {
                    authHtml += `<span style="color: #8AC926; margin-right: 10px;">‚úÖ Telegram: ${userTelegramId}</span>`;
                }
                if (walletAddress) {
                    authHtml += `<div class="wallet-connected">
                        <span>üíé</span>
                        <span class="wallet-address">${walletAddress.slice(0, 4)}...${walletAddress.slice(-4)}</span>
                        <button class="auth-btn" onclick="disconnectWallet()" style="padding: 5px 10px; font-size: 11px; margin-left: 5px;">Disconnect</button>
                    </div>`;
                } else {
                    authHtml += `<button class="auth-btn" onclick="connectPhantomWallet()">Connect Wallet</button>`;
                }
                authSection.innerHTML = authHtml;
                
                // Load balance after updating HTML
                loadAndDisplayBalance();
            } else {
                notAuthScreen.style.display = 'block';
                authContent.style.display = 'none';
                authSection.innerHTML = '<div style="color: rgba(255,255,255,0.5);">Not connected</div>';
            }
        }
        
        // Connect Phantom Wallet
        async function connectPhantomWallet() {
            try {
                if (!window.solana || !window.solana.isPhantom) {
                    alert('Phantom wallet not found! Please install Phantom: https://phantom.app');
                    window.open('https://phantom.app', '_blank');
                    return;
                }
                
                const response = await window.solana.connect();
                walletAddress = response.publicKey.toString();
                phantomWallet = window.solana;
                
                // Link wallet to Telegram account if available
                if (userTelegramId && window.GotchiAuth) {
                    await window.GotchiAuth.linkWalletToTelegramAccount(walletAddress);
                }
                
                updateAuthStatus();
                console.log('‚úÖ Wallet connected:', walletAddress);
            } catch (error) {
                console.error('Failed to connect wallet:', error);
                alert('Failed to connect wallet: ' + error.message);
            }
        }
        
        // Disconnect Wallet
        async function disconnectWallet() {
            try {
                if (phantomWallet) {
                    await phantomWallet.disconnect();
                    walletAddress = null;
                    phantomWallet = null;
                    updateAuthStatus();
                }
            } catch (error) {
                console.error('Failed to disconnect wallet:', error);
            }
        }
        
        // Login via Telegram
        async function loginViaTelegram() {
            if (window.GotchiAuth) {
                await window.GotchiAuth.authViaTelegramWidget();
                updateAuthStatus();
            } else {
                alert('Telegram auth not available. Please open from Telegram bot.');
            }
        }
        
        // Get Telegram user ID from URL or localStorage
        function getTelegramUserId() {
            if (window.GotchiAuth && window.GotchiAuth.isAuthenticated) {
                return window.GotchiAuth.telegramId;
            }
            const urlParams = new URLSearchParams(window.location.search);
            const userId = urlParams.get('user_id') || localStorage.getItem('telegram_user_id');
            return userId;
        }
        
        // Initialize
        async function init() {
            // Initialize auth first
            await initAuth();
            
            // Wait a bit for auth to complete
            setTimeout(() => {
                userTelegramId = getTelegramUserId();
                
                // Update auth status again after delay
                updateAuthStatus();
                
                // Always initialize marketplace (it will show auth screen if needed)
                initMarketplace();
            }, 1000);
        }
        
        // Initialize marketplace features
        function initMarketplace() {
            // Tab switching
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentTab = btn.dataset.tab;
                    loadNFTs();
                });
            });
            
            // Filter changes
            document.getElementById('filter-tier').addEventListener('change', loadNFTs);
            document.getElementById('filter-rarity').addEventListener('change', loadNFTs);
            document.getElementById('filter-sort').addEventListener('change', loadNFTs);
            
            // Price input for sell modal
            document.getElementById('sell-price-tama')?.addEventListener('input', updateSellReceive);
            document.getElementById('sell-price-sol')?.addEventListener('input', updateSellReceive);
            
            loadStats();
            loadNFTs();
        }
        
        // Load marketplace stats
        async function loadStats() {
            try {
                // This would come from API
                // For now, using placeholder
                const response = await fetch(`${API_BASE}/marketplace/stats`);
                if (response.ok) {
                    const stats = await response.json();
                    document.getElementById('total-listed').textContent = stats.total_listed || 0;
                    document.getElementById('total-sales').textContent = stats.total_sales || 0;
                    document.getElementById('floor-price').textContent = stats.floor_price || '-';
                    document.getElementById('volume').textContent = formatNumber(stats.volume || 0);
                }
            } catch (error) {
                console.error('Failed to load stats:', error);
            }
        }
        
        // Load NFTs based on current tab and filters
        async function loadNFTs() {
            const grid = document.getElementById('nft-grid');
            grid.innerHTML = '<div class="loading"><div class="spinner"></div><p>Loading...</p></div>';
            
            try {
                let nfts = [];
                
                if (currentTab === 'browse') {
                    // Load all listed NFTs from API
                    const tier = document.getElementById('filter-tier').value;
                    const rarity = document.getElementById('filter-rarity').value;
                    const sort = document.getElementById('filter-sort').value;
                    
                    const params = new URLSearchParams();
                    if (tier) params.append('tier', tier);
                    if (rarity) params.append('rarity', rarity);
                    if (sort) params.append('sort', sort);
                    
                    const response = await fetch(`${API_BASE}/marketplace/listings?${params}`);
                    if (response.ok) {
                        nfts = await response.json();
                    }
                } else if (currentTab === 'my-listings' && userTelegramId) {
                    // Load user's listings
                    const response = await fetch(`${API_BASE}/marketplace/listings?seller_id=${userTelegramId}`);
                    if (response.ok) {
                        nfts = await response.json();
                    }
                } else if (currentTab === 'my-sales' && userTelegramId) {
                    // Load user's sales history from Supabase
                    const { data: sales, error } = await supabase
                        .from('marketplace_sales')
                        .select('*,user_nfts(tier_name,rarity,earning_multiplier)')
                        .or(`seller_telegram_id.eq.${userTelegramId},buyer_telegram_id.eq.${userTelegramId}`)
                        .order('sold_at', { ascending: false })
                        .limit(50);
                    
                    if (!error && sales) {
                        nfts = sales.map(sale => ({
                            ...sale,
                            tier_name: sale.user_nfts?.tier_name || sale.tier_name,
                            rarity: sale.user_nfts?.rarity || sale.rarity,
                            earning_multiplier: sale.user_nfts?.earning_multiplier,
                            price: sale.sale_price_tama,
                            sold_at: sale.sold_at
                        }));
                    }
                }
                
                displayNFTs(nfts);
            } catch (error) {
                console.error('Failed to load NFTs:', error);
                grid.innerHTML = '<div class="empty-state"><div class="empty-state-icon">üò¢</div><p>Failed to load NFTs. Please try again.</p></div>';
            }
        }
        
        // Load NFT image from blockchain metadata
        async function loadNFTImageFromBlockchain(mintAddress, imageId, fallbackEmoji) {
            try {
                const apiUrl = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
                    ? `http://localhost:3001/api/get-nft-metadata?mint=${encodeURIComponent(mintAddress)}`
                    : `https://solanatamagotchi-onchain.onrender.com/api/get-nft-metadata?mint=${encodeURIComponent(mintAddress)}`;
                
                const apiResponse = await fetch(apiUrl);
                if (apiResponse.ok) {
                    const apiData = await apiResponse.json();
                    if (apiData?.image) {
                        const imgElement = document.getElementById(imageId);
                        if (imgElement) {
                            imgElement.src = apiData.image;
                            imgElement.onerror = function() {
                                console.warn('‚ö†Ô∏è Blockchain image failed, using fallback for:', mintAddress);
                                if (imgElement.parentElement) {
                                    imgElement.parentElement.innerHTML = fallbackEmoji;
                                }
                            };
                        }
                    }
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Failed to load blockchain image for:', mintAddress, error);
            }
        }
        
        // Get static NFT image URL based on tier and rarity (fallback)
        function getNFTImageUrlStatic(tier, rarity) {
            const ipfsUrls = {
                'bronze': {
                    'common': 'https://gateway.lighthouse.storage/ipfs/bafkreidvxzsnozwpgjqbydcncpumcgk3aqmr3evxhqjmf6ibzmrmuv565i',
                    'uncommon': 'https://gateway.lighthouse.storage/ipfs/bafkreibnoiown4k6dyhxvv642ep6av6xwkgtqvusrhhn7l4janrgfjixbq',
                    'rare': 'https://gateway.lighthouse.storage/ipfs/bafkreia7mldvzaw52wvz42od4xdj7asw2fqc7gba7zhdbpfg3d6z3byl5y',
                    'epic': 'https://gateway.lighthouse.storage/ipfs/bafkreiefw2xgoo5w37jkpd6etgr6eurgu7z64tsb7e6bhbbqa5z3qidbbq',
                    'legendary': 'https://gateway.lighthouse.storage/ipfs/bafkreidvxzsnozwpgjqbydcncpumcgk3aqmr3evxhqjmf6ibzmrmuv565i'
                },
                'silver': {
                    'common': 'https://gateway.lighthouse.storage/ipfs/bafkreibp7zxf6fqilehacookucnyhzbqkvaqqbuk3jel7irsa2dzzvnw2a',
                    'uncommon': 'https://gateway.lighthouse.storage/ipfs/bafkreibp7zxf6fqilehacookucnyhzbqkvaqqbuk3jel7irsa2dzzvnw2a',
                    'rare': 'https://gateway.lighthouse.storage/ipfs/bafkreidnwtfwftmcsexgmf6p5qn5jorgwmtl4w2jegyyo7gnynvq2qe334',
                    'epic': 'https://gateway.lighthouse.storage/ipfs/bafkreifkxigyyudtynmn4ffmt2gx7getqs3jfzy2nqdjrzaplpelf3tozq',
                    'legendary': 'https://gateway.lighthouse.storage/ipfs/bafkreigywjdjw3vxopv4blicqioyx5fyqpwcvs22s2ea377rofvh2sslnm'
                },
                'gold': {
                    'common': 'https://gateway.lighthouse.storage/ipfs/bafkreicywzvyse3immuhakmd4dvv22gxsikmzhn4q7cjkmzjpp7253ftse',
                    'uncommon': 'https://gateway.lighthouse.storage/ipfs/bafkreibp7zxf6fqilehacookucnyhzbqkvaqqbuk3jel7irsa2dzzvnw2a',
                    'rare': 'https://gateway.lighthouse.storage/ipfs/bafkreidnwtfwftmcsexgmf6p5qn5jorgwmtl4w2jegyyo7gnynvq2qe334',
                    'epic': 'https://gateway.lighthouse.storage/ipfs/bafkreifkxigyyudtynmn4ffmt2gx7getqs3jfzy2nqdjrzaplpelf3tozq',
                    'legendary': 'https://gateway.lighthouse.storage/ipfs/bafkreigywjdjw3vxopv4blicqioyx5fyqpwcvs22s2ea377rofvh2sslnm'
                },
                'platinum': {
                    'common': 'https://gateway.lighthouse.storage/ipfs/bafkreib72mfqqs5qa3g7asjy4jtoiorxpok3bniknisqznf572haifakcq',
                    'uncommon': 'https://gateway.lighthouse.storage/ipfs/bafkreib72mfqqs5qa3g7asjy4jtoiorxpok3bniknisqznf572haifakcq',
                    'rare': 'https://gateway.lighthouse.storage/ipfs/bafkreib72mfqqs5qa3g7asjy4jtoiorxpok3bniknisqznf572haifakcq',
                    'epic': 'https://gateway.lighthouse.storage/ipfs/bafkreiell36dnbe5oomfigv6yxk65rkbj2eo62t6ihrprbyqbomjraobo4',
                    'legendary': 'https://gateway.lighthouse.storage/ipfs/bafkreiell36dnbe5oomfigv6yxk65rkbj2eo62t6ihrprbyqbomjraobo4'
                },
                'diamond': {
                    'common': 'https://gateway.lighthouse.storage/ipfs/bafkreigflr4x4xczfyl7gavdmaos7uupi73xm2yainwl2tlfn3nabqpsly',
                    'uncommon': 'https://gateway.lighthouse.storage/ipfs/bafkreigflr4x4xczfyl7gavdmaos7uupi73xm2yainwl2tlfn3nabqpsly',
                    'rare': 'https://gateway.lighthouse.storage/ipfs/bafkreigflr4x4xczfyl7gavdmaos7uupi73xm2yainwl2tlfn3nabqpsly',
                    'epic': 'https://gateway.lighthouse.storage/ipfs/bafkreib3la6mkyzjtethphozhsuccp6b4x63dilrz6rsb4tsjvqdxdl5pq',
                    'legendary': 'https://gateway.lighthouse.storage/ipfs/bafkreib3la6mkyzjtethphozhsuccp6b4x63dilrz6rsb4tsjvqdxdl5pq'
                }
            };
            
            const tierLower = (tier || '').toLowerCase();
            const rarityLower = (rarity || '').toLowerCase();
            
            const imageUrl = ipfsUrls[tierLower]?.[rarityLower];
            
            if (imageUrl) {
                console.log(`üé® Found IPFS image for ${tier} ${rarity}:`, imageUrl);
            } else {
                console.warn(`‚ö†Ô∏è No IPFS image for ${tier} ${rarity}`);
            }
            
            return imageUrl || null;
        }
        
        // Display NFTs in grid
        function displayNFTs(nfts) {
            const grid = document.getElementById('nft-grid');
            
            if (!nfts || nfts.length === 0) {
                grid.innerHTML = '<div class="empty-state"><div class="empty-state-icon">üì¶</div><p>No NFTs found</p></div>';
                return;
            }
            
            grid.innerHTML = nfts.map(nft => {
                const tierEmoji = getTierEmoji(nft.tier_name);
                const rarityEmoji = getRarityEmoji(nft.rarity);
                const petEmoji = getPetEmoji(nft.pet_type); // üê±üê∂ü¶äüêº
                
                // Get NFT image URL - ALWAYS try to show IPFS image first, then blockchain
                const imageId = `marketplace-nft-image-${nft.id || nft.nft_mint_address || Math.random()}`;
                const isRealOnChain = nft.nft_mint_address && 
                    nft.nft_mint_address.length > 30 && 
                    !nft.nft_mint_address.includes('_');
                
                // Try to get IPFS image URL first
                const staticImageUrl = nft.tier_name && nft.rarity ? getNFTImageUrlStatic(nft.tier_name, nft.rarity) : null;
                
                // Build image HTML
                let imageHtml = `<div class="nft-image">${petEmoji}</div>`;
                
                if (staticImageUrl) {
                    // Use IPFS image directly (fastest!)
                    imageHtml = `<div class="nft-image" style="background: linear-gradient(135deg, rgba(138, 201, 38, 0.2), rgba(16, 185, 129, 0.2)); display: flex; align-items: center; justify-content: center; padding: 0;">
                        <img id="${imageId}" 
                             src="${staticImageUrl}" 
                             onerror="this.parentElement.innerHTML='${petEmoji}'"
                             style="width: 100%; height: 100%; object-fit: cover; border-radius: 15px;" />
                    </div>`;
                    
                    // If on-chain, try to load better quality image from blockchain (async)
                    if (isRealOnChain) {
                        setTimeout(() => loadNFTImageFromBlockchain(nft.nft_mint_address, imageId, petEmoji), 500);
                    }
                } else if (isRealOnChain) {
                    // No IPFS image, try blockchain only
                    imageHtml = `<div class="nft-image" style="background: linear-gradient(135deg, rgba(138, 201, 38, 0.2), rgba(16, 185, 129, 0.2)); display: flex; align-items: center; justify-content: center; padding: 0;">
                        <img id="${imageId}" 
                             src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='200' height='200'%3E%3Ctext x='50%25' y='50%25' text-anchor='middle' dy='.3em' font-size='48'%3E${petEmoji}%3C/text%3E%3C/svg%3E"
                             onerror="this.parentElement.innerHTML='${petEmoji}'"
                             style="width: 100%; height: 100%; object-fit: cover; border-radius: 15px;" />
                    </div>`;
                    
                    loadNFTImageFromBlockchain(nft.nft_mint_address, imageId, petEmoji);
                }
                
                return `
                    <div class="nft-card" onclick="${currentTab === 'browse' ? `openBuyModal(${JSON.stringify(nft).replace(/"/g, '&quot;')})` : ''}">
                        ${nft.is_listed || currentTab === 'browse' ? '<div class="nft-badge">FOR SALE</div>' : ''}
                        ${imageHtml}
                        <div class="nft-info">
                            <div class="nft-name">${tierEmoji} ${nft.tier_name || 'Unknown'}</div>
                            <div class="nft-attributes">
                                <span class="attribute-badge">${rarityEmoji} ${nft.rarity || 'Common'}</span>
                                <span class="attribute-badge">‚ö° ${nft.earning_multiplier || 1.0}x</span>
                                ${nft.nft_mint_address ? '<span class="attribute-badge" style="background: rgba(138, 201, 38, 0.3);">üîó On-Chain</span>' : ''}
                            </div>
                        </div>
                        ${(nft.price || nft.price_tama || nft.price_sol) ? `
                            <div class="nft-price">
                                <div>
                                    <div class="price-label">Price</div>
                                    ${(() => {
                                        const priceTama = nft.price || nft.price_tama;
                                        const priceSol = nft.price_sol;
                                        if (priceTama && priceSol) {
                                            return `<div class="price-value">${formatNumber(priceTama)} TAMA / ${formatNumber(priceSol)} SOL</div>`;
                                        } else if (priceTama) {
                                            return `<div class="price-value">${formatNumber(priceTama)} TAMA</div>`;
                                        } else if (priceSol) {
                                            return `<div class="price-value">${formatNumber(priceSol)} SOL</div>`;
                                        }
                                        return '';
                                    })()}
                                </div>
                            </div>
                            ${currentTab === 'browse' ? '<button class="btn btn-buy" onclick="event.stopPropagation(); openBuyModal(' + JSON.stringify(nft).replace(/"/g, '&quot;') + ')">Buy Now</button>' : ''}
                        ` : ''}
                        ${currentTab === 'my-listings' ? `
                            <div class="nft-actions">
                                <button class="btn btn-cancel" onclick="event.stopPropagation(); cancelListing(${nft.listing_id || nft.id})">Cancel</button>
                            </div>
                        ` : ''}
                    </div>
                `;
            }).join('');
        }
        
        // Open sell modal
        async function openSellModal() {
            // Update userTelegramId before checking
            userTelegramId = getTelegramUserId();
            
            if (!isAuthenticated && !userTelegramId && !walletAddress) {
                alert('Please connect wallet or login via Telegram first');
                return;
            }
            
            const modal = document.getElementById('sell-modal');
            const select = document.getElementById('sell-nft-select');
            
            // Show loading state
            select.innerHTML = '<option value="">Loading your NFTs...</option>';
            modal.classList.add('active');
            
            // Load user's NFTs from Supabase
            try {
                let nfts = [];
                let query = supabase
                    .from('user_nfts')
                    .select('*')
                    .eq('is_active', true);
                
                // Try to find NFTs by telegram_id first
                if (userTelegramId) {
                    console.log('Loading NFTs for Telegram ID:', userTelegramId);
                    const { data, error } = await query
                        .eq('telegram_id', userTelegramId.toString())
                        .order('minted_at', { ascending: false });
                    
                    if (error) {
                        console.error('Error loading NFTs by telegram_id:', error);
                    } else {
                        nfts = data || [];
                        console.log('Found NFTs by telegram_id:', nfts.length);
                    }
                }
                
                // If no NFTs found and wallet is connected, try to find by wallet address
                if (nfts.length === 0 && walletAddress) {
                    console.log('Loading NFTs for wallet:', walletAddress);
                    // Check if wallet is linked to a telegram account
                    const { data: leaderboardData } = await supabase
                        .from('leaderboard')
                        .select('telegram_id')
                        .eq('wallet_address', walletAddress)
                        .maybeSingle();
                    
                    if (leaderboardData && leaderboardData.telegram_id) {
                        const { data, error } = await supabase
                            .from('user_nfts')
                            .select('*')
                            .eq('telegram_id', leaderboardData.telegram_id.toString())
                            .eq('is_active', true)
                            .order('minted_at', { ascending: false });
                        
                        if (error) {
                            console.error('Error loading NFTs by linked wallet:', error);
                        } else {
                            nfts = data || [];
                            console.log('Found NFTs by linked wallet:', nfts.length);
                        }
                    }
                }
                
                if (nfts.length === 0) {
                    select.innerHTML = '<option value="">No NFTs found. Mint an NFT first!</option>';
                    console.warn('No NFTs found for user');
                    return;
                }
                
                // Filter out already listed NFTs
                const { data: listings, error: listingsError } = await supabase
                    .from('marketplace_listings')
                    .select('nft_id')
                    .eq('status', 'active');
                
                if (listingsError) {
                    console.error('Error loading listings:', listingsError);
                }
                
                const listedNftIds = new Set((listings || []).map(l => l.nft_id));
                const availableNfts = nfts.filter(nft => !listedNftIds.has(nft.id) && !nft.is_listed);
                
                if (availableNfts.length === 0) {
                    select.innerHTML = '<option value="">All your NFTs are already listed</option>';
                    return;
                }
                
                select.innerHTML = '<option value="">Select NFT...</option>' + 
                    availableNfts.map(nft => 
                        `<option value="${nft.id}">${getTierEmoji(nft.tier_name)} ${nft.tier_name} - ${nft.rarity || 'Common'} (${nft.earning_multiplier}x)${nft.nft_mint_address ? ' [On-Chain]' : ''}</option>`
                    ).join('');
                
                console.log('Loaded', availableNfts.length, 'available NFTs');
            } catch (error) {
                console.error('Failed to load NFTs:', error);
                select.innerHTML = '<option value="">Error loading NFTs. Please try again.</option>';
                alert('Failed to load NFTs: ' + error.message);
            }
        }
        
        function closeSellModal() {
            document.getElementById('sell-modal').classList.remove('active');
        }
        
        function updateSellForm() {
            const paymentType = document.getElementById('sell-payment-type').value;
            const tamaGroup = document.getElementById('sell-price-tama-group');
            const solGroup = document.getElementById('sell-price-sol-group');
            const receiveCurrency = document.getElementById('sell-receive-currency');
            
            if (paymentType === 'tama') {
                tamaGroup.style.display = 'block';
                solGroup.style.display = 'none';
                receiveCurrency.textContent = 'TAMA';
            } else if (paymentType === 'sol') {
                tamaGroup.style.display = 'none';
                solGroup.style.display = 'block';
                receiveCurrency.textContent = 'SOL';
            } else { // both
                tamaGroup.style.display = 'block';
                solGroup.style.display = 'block';
                receiveCurrency.textContent = 'TAMA or SOL';
            }
            updateSellReceive();
        }
        
        function updateSellReceive() {
            const paymentType = document.getElementById('sell-payment-type').value;
            let receive = 0;
            
            if (paymentType === 'tama' || paymentType === 'both') {
                const priceTama = parseFloat(document.getElementById('sell-price-tama')?.value) || 0;
                receive = Math.floor(priceTama * 0.95);
            } else if (paymentType === 'sol') {
                const priceSol = parseFloat(document.getElementById('sell-price-sol')?.value) || 0;
                receive = (priceSol * 0.95).toFixed(6);
            }
            
            document.getElementById('sell-receive').textContent = formatNumber(receive);
        }
        
        // List NFT for sale
        async function listNFT() {
            // Update userTelegramId before sending
            userTelegramId = getTelegramUserId();
            
            // If no telegram_id, try to find it via wallet address
            if (!userTelegramId && walletAddress) {
                console.log('No telegram_id found, searching via wallet address...');
                const { data: leaderboardData } = await supabase
                    .from('leaderboard')
                    .select('telegram_id')
                    .eq('wallet_address', walletAddress)
                    .maybeSingle();
                
                if (leaderboardData && leaderboardData.telegram_id) {
                    userTelegramId = leaderboardData.telegram_id.toString();
                    console.log('Found telegram_id via wallet:', userTelegramId);
                }
            }
            
            const nftId = document.getElementById('sell-nft-select').value;
            const paymentType = document.getElementById('sell-payment-type').value;
            const priceTama = paymentType === 'sol' ? null : parseFloat(document.getElementById('sell-price-tama')?.value);
            const priceSol = paymentType === 'tama' ? null : parseFloat(document.getElementById('sell-price-sol')?.value);
            
            if (!nftId) {
                alert('Please select an NFT');
                return;
            }
            
            if (!userTelegramId) {
                alert('Telegram ID not found. Please login via Telegram or link your wallet to a Telegram account.');
                return;
            }
            
            if (paymentType === 'tama' && (!priceTama || priceTama < 1000)) {
                alert('Please enter a price (minimum 1,000 TAMA)');
                return;
            }
            
            if (paymentType === 'sol' && (!priceSol || priceSol < 0.001)) {
                alert('Please enter a price (minimum 0.001 SOL)');
                return;
            }
            
            if (paymentType === 'both' && (!priceTama || priceTama < 1000) && (!priceSol || priceSol < 0.001)) {
                alert('Please enter at least one price (TAMA: min 1,000, SOL: min 0.001)');
                return;
            }
            
            try {
                const body = {
                    telegram_id: userTelegramId,
                    nft_id: parseInt(nftId),
                    payment_type: paymentType
                };
                
                if (priceTama) {
                    body.price = Math.floor(priceTama);
                }
                if (priceSol) {
                    body.price_sol = priceSol;
                }
                
                console.log('Sending listing request:', body);
                
                const response = await fetch(`${API_BASE}/marketplace/list`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
                
                if (response.ok) {
                    const result = await response.json();
                    alert('‚úÖ NFT listed successfully!');
                    closeSellModal();
                    loadNFTs();
                    loadStats();
                    loadAndDisplayBalance(); // Update balance
                } else {
                    const error = await response.json();
                    console.error('Listing error:', error);
                    alert('Failed to list NFT: ' + (error.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Listing exception:', error);
                alert('Failed to list NFT: ' + error.message);
            }
        }
        
        // Open buy modal
        function openBuyModal(nft) {
            selectedNFT = nft;
            const modal = document.getElementById('buy-modal');
            const details = document.getElementById('buy-details');
            
            // Get NFT image
            const petEmoji = getPetEmoji(nft.pet_type);
            const staticImageUrl = nft.tier_name && nft.rarity ? getNFTImageUrlStatic(nft.tier_name, nft.rarity) : null;
            
            let nftImageHtml = `<div style="font-size: 80px; margin-bottom: 10px;">${petEmoji}</div>`;
            if (staticImageUrl) {
                nftImageHtml = `
                    <div style="width: 200px; height: 200px; margin: 0 auto 15px; border-radius: 15px; overflow: hidden; background: linear-gradient(135deg, rgba(138, 201, 38, 0.2), rgba(16, 185, 129, 0.2));">
                        <img src="${staticImageUrl}" 
                             onerror="this.parentElement.innerHTML='<div style=\\'display:flex;align-items:center;justify-content:center;height:100%;font-size:80px;\\'>${petEmoji}</div>'"
                             style="width: 100%; height: 100%; object-fit: cover;" />
                    </div>`;
            }
            
            details.innerHTML = `
                <div style="text-align: center; margin-bottom: 20px;">
                    ${nftImageHtml}
                    <div style="font-size: 20px; color: #8AC926; font-weight: bold; margin-bottom: 10px;">
                        ${getTierEmoji(nft.tier_name)} ${nft.tier_name}
                    </div>
                    <div style="display: flex; gap: 10px; justify-content: center; margin-bottom: 15px;">
                        <span class="attribute-badge">${getRarityEmoji(nft.rarity)} ${nft.rarity}</span>
                        <span class="attribute-badge">‚ö° ${nft.earning_multiplier}x</span>
                    </div>
                </div>
            `;
            
            // Display price based on payment type
            let priceText = '';
            let feeText = '';
            let totalText = '';
            
            if (nft.payment_type === 'tama' || nft.payment_type === 'both') {
                const priceTama = nft.price || nft.price_tama || 0;
                const feeTama = Math.floor(priceTama * 0.05);
                const totalTama = priceTama + feeTama;
                priceText = formatNumber(priceTama) + ' TAMA';
                feeText = formatNumber(feeTama) + ' TAMA';
                totalText = formatNumber(totalTama) + ' TAMA';
            }
            
            if (nft.payment_type === 'sol' || nft.payment_type === 'both') {
                const priceSol = nft.price_sol || 0;
                const feeSol = (priceSol * 0.05).toFixed(6);
                const totalSol = (priceSol + parseFloat(feeSol)).toFixed(6);
                
                if (priceText) {
                    priceText += ' / ' + formatNumber(priceSol) + ' SOL';
                    feeText += ' / ' + formatNumber(feeSol) + ' SOL';
                    totalText += ' / ' + formatNumber(totalSol) + ' SOL';
                } else {
                    priceText = formatNumber(priceSol) + ' SOL';
                    feeText = formatNumber(feeSol) + ' SOL';
                    totalText = formatNumber(totalSol) + ' SOL';
                }
            }
            
            document.getElementById('buy-price').textContent = priceText || '0 TAMA';
            document.getElementById('buy-fee').textContent = feeText || '0 TAMA';
            document.getElementById('buy-total').textContent = totalText || '0 TAMA';
            
            // Load user balance
            loadUserBalance(nft.payment_type);
            
            modal.classList.add('active');
        }
        
        function closeBuyModal() {
            document.getElementById('buy-modal').classList.remove('active');
            selectedNFT = null;
        }
        
        async function loadUserBalance(paymentType) {
            if (!userTelegramId && !walletAddress) return;
            
            try {
                let balanceTama = 0;
                let balanceSol = 0;
                
                // Load TAMA balance
                if (userTelegramId && (paymentType === 'tama' || paymentType === 'both')) {
                    const response = await fetch(`${API_BASE}/balance?telegram_id=${userTelegramId}`);
                    if (response.ok) {
                        const data = await response.json();
                        balanceTama = data.balance || 0;
                    }
                }
                
                // Load SOL balance
                if (walletAddress && (paymentType === 'sol' || paymentType === 'both')) {
                    const solBalanceLamports = await connection.getBalance(new solanaWeb3.PublicKey(walletAddress));
                    balanceSol = solBalanceLamports / solanaWeb3.LAMPORTS_PER_SOL;
                }
                
                // Display balance
                let balanceHtml = '';
                if (paymentType === 'tama' || paymentType === 'both') {
                    balanceHtml = formatNumber(balanceTama) + ' TAMA';
                }
                if (paymentType === 'sol' || paymentType === 'both') {
                    if (balanceHtml) balanceHtml += ' / ';
                    balanceHtml += formatNumber(balanceSol) + ' SOL';
                }
                document.getElementById('buy-balance').textContent = balanceHtml || 'Loading...';
                
                // Check if user can afford
                const buyBtn = document.getElementById('buy-btn');
                let canBuy = true;
                
                if (paymentType === 'tama' || paymentType === 'both') {
                    const priceTama = selectedNFT.price || selectedNFT.price_tama || 0;
                    const feeTama = Math.floor(priceTama * 0.05);
                    const totalTama = priceTama + feeTama;
                    if (balanceTama < totalTama) {
                        canBuy = false;
                    }
                }
                if (paymentType === 'sol' || paymentType === 'both') {
                    const priceSol = selectedNFT.price_sol || 0;
                    const feeSol = (priceSol * 0.05);
                    const totalSol = priceSol + feeSol;
                    if (balanceSol < totalSol) {
                        canBuy = false;
                    }
                }
                
                if (!canBuy) {
                    buyBtn.disabled = true;
                    buyBtn.textContent = '‚ùå Insufficient Balance';
                } else {
                    buyBtn.disabled = false;
                    buyBtn.textContent = 'üí∞ Buy Now';
                }
            } catch (error) {
                console.error('Failed to load balance:', error);
                document.getElementById('buy-balance').textContent = 'Error loading balance';
            }
        }
        
        // Buy NFT
        async function buyNFT() {
            if (!selectedNFT) {
                alert('Please select an NFT');
                return;
            }
            
            if (!isAuthenticated && !userTelegramId && !walletAddress) {
                alert('Please connect wallet or login via Telegram first');
                return;
            }
            
            // For SOL payments, need wallet
            if (selectedNFT.payment_type === 'sol' && !walletAddress) {
                alert('Please connect Phantom wallet to buy with SOL');
                await connectPhantomWallet();
                return;
            }
            
            // For TAMA payments, need Telegram ID
            if (selectedNFT.payment_type === 'tama' && !userTelegramId) {
                alert('Please login via Telegram to buy with TAMA');
                await loginViaTelegram();
                return;
            }
            
            if (!confirm(`Buy ${selectedNFT.tier_name} NFT for ${formatNumber(selectedNFT.price)} TAMA?`)) {
                return;
            }
            
            try {
                // Update telegram_id before buying
                const buyerTelegramId = userTelegramId || getTelegramUserId();
                
                // If still no telegram_id and wallet is connected, try to find via wallet
                let finalTelegramId = buyerTelegramId;
                if (!finalTelegramId && walletAddress) {
                    const { data: leaderboardData } = await supabase
                        .from('leaderboard')
                        .select('telegram_id')
                        .eq('wallet_address', walletAddress)
                        .maybeSingle();
                    
                    if (leaderboardData && leaderboardData.telegram_id) {
                        finalTelegramId = leaderboardData.telegram_id.toString();
                    }
                }
                
                if (!finalTelegramId) {
                    alert('‚ùå Telegram ID not found. Please login via Telegram.');
                    return;
                }
                
                console.log('üõí Buying NFT:', {
                    buyer_telegram_id: finalTelegramId,
                    seller_telegram_id: selectedNFT.seller_telegram_id,
                    listing_id: selectedNFT.listing_id || selectedNFT.id
                });
                
                const response = await fetch(`${API_BASE}/marketplace/buy`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        telegram_id: finalTelegramId,
                        listing_id: selectedNFT.listing_id || selectedNFT.id
                    })
                });
                
                if (response.ok) {
                    alert('‚úÖ NFT purchased successfully!');
                    closeBuyModal();
                    loadNFTs();
                    loadStats();
                    loadAndDisplayBalance(); // Update balance
                } else {
                    const error = await response.json();
                    console.error('‚ùå Buy failed:', error);
                    alert('Failed to buy NFT: ' + (error.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('‚ùå Buy exception:', error);
                alert('Failed to buy NFT: ' + error.message);
            }
        }
        
        // Helper functions
        function getPetEmoji(type) {
            const emojis = {
                'cat': 'üê±', 'dog': 'üê∂', 'dragon': 'üêâ', 'fox': 'ü¶ä',
                'bear': 'üêª', 'rabbit': 'üê∞', 'panda': 'üêº', 'tiger': 'üêØ',
                'lion': 'ü¶Å', 'wolf': 'üê∫'
            };
            return emojis[type?.toLowerCase()] || 'üêæ';
        }
        
        function getTierEmoji(tier) {
            const emojis = {
                'Bronze': 'ü•â', 'Silver': 'ü•à', 'Gold': 'ü•á'
            };
            return emojis[tier] || 'üé®';
        }
        
        function getRarityEmoji(rarity) {
            const emojis = {
                'Common': '‚ö™', 'Uncommon': 'üü¢', 'Rare': 'üîµ',
                'Epic': 'üü£', 'Legendary': 'üü†'
            };
            return emojis[rarity] || '‚ö™';
        }
        
        function formatNumber(num) {
            return new Intl.NumberFormat('en-US').format(Math.floor(num));
        }
        
        // Cancel listing
        async function cancelListing(listingId) {
            if (!userTelegramId) {
                alert('Please login first');
                return;
            }
            
            if (!confirm('Cancel this listing?')) {
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE}/marketplace/cancel`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        telegram_id: userTelegramId,
                        listing_id: listingId
                    })
                });
                
                if (response.ok) {
                    alert('‚úÖ Listing cancelled!');
                    loadNFTs();
                    loadStats();
                } else {
                    const error = await response.json();
                    alert('Failed to cancel: ' + (error.error || 'Unknown error'));
                }
            } catch (error) {
                alert('Failed to cancel: ' + error.message);
            }
        }
        
        // Initialize on load
        init();
    </script>
</body>
</html>






